/**
 * Source: https://github.com/udecode/slate-plugins/blob/next/packages/slate-plugins/src/serializers/serialize-html/serializeHTMLFromNodes.ts
 */

import React from 'react';
import { renderToStaticMarkup } from 'react-dom/server';
import { Text as SlateText } from 'slate';

// Remove extra whitespace generated by ReactDOMServer
const trimWhitespace = (rawHtml) => rawHtml.replace(/(\r\n|\n|\r|\t)/gm, '');

// Remove redundant data attributes
const stripSlateDataAttributes = (rawHtml) =>
  rawHtml
    .replace(/( data-slate)(-node|-type)="[^"]+"/gm, '')
    .replace(/( data-testid)="[^"]+"/gm, '');

// TODO: We might also want to remove generated classes in the future.

const getNode = (elementProps, plugins) => {
  // If no type provided we wrap children with div tag
  // if (!elementProps.element.type) {
  //   return `<div>${elementProps.children}</div>`;
  // }

  // Search for matching plugin based on element type
  // const elementPlugin = plugins
  //   .filter((plugin) => plugin.renderElement)
  //   .find((plugin) => {
  //     return Object.keys(plugin.deserialize?.element).includes(
  //       String(elementProps.element.type),
  //     );
  //   });

  // Render element using picked plugins renderElement function and ReactDOM
  // if (elementPlugin?.renderElement) {
  // return renderToStaticMarkup(elementPlugin.renderElement(elementProps));
  // }
  let ElementProps = elementProps;
  return renderToStaticMarkup(<ElementProps />);
};

const getLeaf = (leafProps, plugins) => {
  // These lines remove the leaf from the output if there are no plugins specified:
  // const { children } = leafProps;
  // return (
  //   plugins
  //     .filter((plugin) => plugin.renderLeaf)
  //     .filter(({ renderLeaf }) => renderLeaf?.(leafProps) !== children)
  //     .reduce((result, plugin) => {
  //       const newLeafProps = {
  //         ...leafProps,
  //         children: encodeURIComponent(result),
  //       };
  //       if (plugin?.renderLeaf) {
  //         return decodeURIComponent(
  //           renderToStaticMarkup(plugin.renderLeaf(newLeafProps)),
  //         );
  //       }
  //       return result;
  //     }, children)
  // );

  // Only one leaf type: Text elements:
  return leafProps.children;
};

/**
 *
 * @param plugins
 */
export const serializeHTMLFromNodes = (plugins) => (nodes) => {
  const result = nodes
    .map((node) => {
      if (SlateText.isText(node)) {
        return getLeaf(
          {
            leaf: node,
            text: node,
            children: node.text,
            attributes: { 'data-slate-leaf': true },
          },
          plugins,
        );
      }
      return getNode(
        {
          element: node,
          children: encodeURIComponent(
            serializeHTMLFromNodes(plugins)(node.children),
          ),
          attributes: { 'data-slate-node': 'element', ref: null },
        },
        plugins,
      );
    })
    .join('');
  return stripSlateDataAttributes(trimWhitespace(decodeURIComponent(result)));
};
